<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI EQ Research Hub - Phase 1</title>
    <link rel="stylesheet" href="style.css">
    <link rel="icon" href="assets/images/favicon.png">
</head>
<body>
    <a class="skip-link" href="#main">Skip to main content</a>
    <header>
        <nav class="site-nav main-menu" aria-label="Primary">
            <button class="nav-toggle" aria-label="Toggle navigation">&#9776;</button>
            <ul>
                <li><a href="index.html">AI EQ Research Hub</a></li>
                <li class="dropdown">
                    <a href="research.html">Our Research Project</a>
                    <ul>
                        <li><a href="phase1.html">Phase 1</a></li>
                        <li><a href="phase2.html">Phase 2</a></li>
                        <li><a href="phase3.html">Phase 3</a></li>
                        <li><a href="phase4.html">Phase 4</a></li>
                    </ul>
                </li>
                <li><a href="expert-collaborators.html">Our Team</a></li>
                <li><a href="https://github.com/maxaeon/EQ-bench">GitHub Repository</a></li>
            </ul>
        </nav>

    </header>
    <main id="main" class="wide">
        <section id="contribute">
            <h1>Phase 1: Framework Feedback and Literature Scan</h1>
            <div class="subsection">
                <h3>Goal</h3>
                <p>Establish a theoretical foundation for EQ benchmarking through literature synthesis.</p>
            </div>
            <div class="subsection">
                <h3>Methodology</h3>
                <ul>
                    <li>Systematic reviews across Philosophy, Psychology, Neuroscience, Computer Science</li>
                    <li>Database creation detailing constructs, definitions, measurement methods, SERA-X axes alignment</li>
                </ul>
            </div>
            <hr>
            <h2>Axis Feedback</h2>
            <p>We are gathering input on the proposed SERA-X axes and compiling relevant peerâ€‘reviewed literature. As an introductory project, contributors and collaborators are encouraged to familiarize themselves with existing emotional intelligence benchmarking frameworks. Please review our detailed comparison here:</p>
            <p><a href="alternative-models.html"><strong>Comparison of Alternative Emotional Intelligence Models</strong></a></p>
<p>For an overview of the SERA-X axes, see the <a href="axes.html">SERA-X Axes page</a>.</p>
            <p>Please explore the references below. Editing is currently open so you can add or update sources directly in our Supabase database. For broader comments on the SERA-X framework, let us know via our <a href="https://github.com/maxaeon/EQ-bench/issues/new?template=feedback.yml" target="_blank">feedback form</a>.</p>
        </section>


        <section id="literature">
            <hr>
            <h2>Relevant Literature</h2>
<p>Notice something missing? Use the <strong>Add Source</strong> button to submit new references. Logged-in contributors may also import a <code>.bib</code> file or paste BibTeX text directly, and the entries will be saved to our Supabase database. Each submission must specify at least one of the supported SERA-X axes, a related construct, or the methodology it informs.</p>
<p>Need to modify the database structure itself? <a href="https://github.com/maxaeon/EQ-bench/issues/new?template=database-change.yml" target="_blank">Open a database change request</a>.</p>
            <div class="add-source-controls">
                <button id="bibtex-btn" class="button" type="button">BibTeX</button>
                <button id="add-source-btn" class="button" type="button">Add Source</button>
            </div>

            <div class="search-controls">
                <label for="lit-search">Search:</label>
                <input type="search" id="lit-search" placeholder="Search literature">
            </div>
            
            <div class="controls-row">
                <div class="filter-controls">
                    <label for="lit-axis-filter">Axis:</label>
                    <select id="lit-axis-filter" multiple size="1">
                        <option value="">All</option>
                    </select>
                    <label for="lit-construct-filter">Construct:</label>
                    <select id="lit-construct-filter" multiple size="1">
                        <option value="">All</option>
                    </select>
                    <label for="lit-field-filter">Field/Topic:</label>
                    <select id="lit-field-filter" multiple size="1">
                        <option value="">All</option>
                    </select>
                </div>
                <div class="sort-controls">
                    <label for="lit-sort">Sort by:</label>
                    <select id="lit-sort">
                        <option value="year">Year</option>
                        <option value="author">Author</option>
                        <option value="title">Title</option>
                    </select>
                </div>
            </div>
            <div class="table-scroll">
            <table id="lit-table">
                <thead>
                    <tr>
                        <th><input type="checkbox" id="lit-select-all"></th>
                        <th>Title</th>
                        <th>Author(s)</th>
                        <th>Year</th>
                        <th>Relevance</th>
                        <th>Construct</th>
                        <th>Axis</th>
                        <th>Methodology Supported</th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
            </div>
        </section>
        <div class="bibtex-controls">
            <!--<a class="button" href="#" id="bibtex-download">Download BibTeX</a> -->
            <a class="button" href="#" id="bibtex-export-filtered" title="Export currently filtered list">Export Bib</a>
            <button id="edit-lit-btn" class="button">Edit</button>
            <button id="delete-lit-btn" class="button">Delete</button>
            <button id="undo-lit-btn" class="button">Undo</button>
        </div>

            <hr style="margin-top: 40px; margin-bottom: 20px;">

            <div style="padding:20px; background-color:#f9f9f9; border-radius:8px; border: 1px solid #ddd;">
              <hr>
              <h2>Collaborative Literature Review</h2>
              <p>
                We encourage all contributors to help build our interdisciplinary literature review directly in our shared Overleaf project. Your input is essential in identifying and synthesizing relevant sources from philosophy, psychology, neuroscience, and computer science.
              </p>
              <p style="margin-top:15px;">
                ðŸ”— <a href="https://www.overleaf.com/4957755681mcqwpwkcyjrq#be11ce" target="_blank" style="font-weight:bold; color:#0066cc;">Access the collaborative Overleaf document here</a>
              </p>
              <p style="font-size: 0.9em; color: #666;">
                (No Overleaf account is required to view or edit. Please add brief summaries, relevant references, and foundational resources.)
              </p>
            </div>

    </main>
    <footer>
        <p>&copy; AI EQ Research Collaborative</p>
    </footer>
    <script>

    let literature = [];
    let filteredLiterature = [];

    function toTitle(text) {
        return text.replace(/(^|\s)\S/g, t => t.toUpperCase());
    }

    const selectedLit = new Set();
    let selectedLitId = null;
    let lastLitAction = null;

    function toBibtex(item) {
        const type = item.journal ? 'article' : 'book';
        const firstAuthor = Array.isArray(item.authors)
            ? (item.authors.length ? item.authors[0] : 'ref')
            : (item.authors || 'ref');
        const keyAuthor = String(firstAuthor || 'ref')
            .split(/[ ,]/)[0]
            .replace(/[^a-zA-Z0-9]/g, '') || 'ref';
        const key = keyAuthor + (item.year || '');
        const mapping = {
            title: 'title',
            authors: 'author',
            journal: 'journal',
            publisher: 'publisher',
            volume: 'volume',
            number: 'number',
            pages: 'pages',
            year: 'year',
            url: 'url',
            doi: 'doi',
            keywords: 'keywords',
            relevance: 'note'
        };
        const fields = {};
        for (const [prop, tag] of Object.entries(mapping)) {
            let val = item[prop];
            if (val === undefined || val === null || val === '' || (Array.isArray(val) && !val.length)) continue;
            if (prop === 'keywords') val = Array.isArray(val) ? val.join(', ') : val;
            if (prop === 'authors') val = Array.isArray(val) ? val.join(' and ') : val;
            fields[tag] = val;
        }
        for (const [k,v] of Object.entries(item)) {
            if (!(k in mapping) && k !== '__index' && v !== undefined && v !== null && v !== '' && !(Array.isArray(v) && !v.length)) {
                fields[k] = Array.isArray(v) ? v.join(', ') : v;
            }
        }
        const body = Object.entries(fields).map(([k,v]) => `  ${k} = {${v}}`).join(',\n');
        return `@${type}{${key},\n${body}\n}`;
    }

    function downloadFile(content, filename) {
        const blob = new Blob([content], {type: 'text/x-bibtex'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        URL.revokeObjectURL(url);
        a.remove();
    }

    function updateSelectAll() {
        const cbs = document.querySelectorAll('#lit-table tbody .lit-check');
        const allChecked = cbs.length && Array.from(cbs).every(cb => cb.checked);
        document.getElementById('lit-select-all').checked = allChecked;
    }




    function renderLit(items) {
        const tbody = document.querySelector('#lit-table tbody');
        tbody.innerHTML = '';
        if (!items.length) {
            const row = document.createElement('tr');
            row.innerHTML = `<td colspan="8">No literature found. Try adjusting your filters.</td>`;
            tbody.appendChild(row);
            return;
        }
        items.forEach(l => {
            const checked = selectedLit.has(l.__index) ? 'checked' : '';
            const row = document.createElement('tr');
            row.className = 'lit-row';
            row.dataset.lid = l.id ?? l.__index;
            row.id = `lit-row-${l.id ?? l.__index}`;
            row.innerHTML = `
                <td><input type="checkbox" class="lit-check" data-index="${l.__index}" ${checked}></td>
                <td>${l.title}</td>
                <td>${Array.isArray(l.authors) ? l.authors.join(', ') : l.authors}</td>
                <td>${l.year}</td>
                <td>${l.relevance || ''}</td>
                <td>${(Array.isArray(l.construct) ? l.construct : (l.construct || '').split(/[,;]+/)).map(c => c.trim()).filter(Boolean).join('<br>')}</td>
                <td>${Array.isArray(l.axis) ? l.axis.join(', ') : l.axis}</td>
                <td>${l.methodology_supported || ''}</td>`;
            const extra = document.createElement('tr');
            const id = `ldetail-${l.__index}`;
            row.dataset.target = id;
            extra.className = 'lit-extra';
            extra.id = id;
            extra.style.display = 'none';
            const keywords = Array.isArray(l.keywords) ? l.keywords.join(', ') : (l.keywords || '');
            extra.innerHTML = `
                <td colspan="8">${l.publisher ? `<strong>Publisher:</strong> ${l.publisher}<br>` : ''}
                ${l.journal ? `<strong>Journal:</strong> ${l.journal}<br>` : ''}
                ${l.volume ? `<strong>Volume:</strong> ${l.volume} ` : ''}${l.number ? ` <strong>Number:</strong> ${l.number}` : ''}${(l.volume||l.number)?'<br>':''}
                ${l.pages ? `<strong>Pages:</strong> ${l.pages}<br>` : ''}
                ${l.url ? `<strong>URL:</strong> <a href="${l.url}">${l.url}</a><br>` : ''}
                ${l.category ? `<strong>Category:</strong> ${Array.isArray(l.category) ? l.category.join(', ') : l.category}<br>` : ''}
                ${keywords ? `<strong>Keywords:</strong> ${keywords}` : ''}</td>`;
            tbody.appendChild(row);
            tbody.appendChild(extra);
        });
        tbody.querySelectorAll('.lit-check').forEach(cb => {
            cb.addEventListener('change', () => {
                const idx = parseInt(cb.dataset.index, 10);
                if (cb.checked) {
                    selectedLit.add(idx);
                    const row = cb.closest('.lit-row');
                    if (row) {
                        tbody.querySelectorAll('.lit-row').forEach(x => x.classList.remove('selected'));
                        row.classList.add('selected');
                        selectedLitId = row.dataset.lid || row.id.replace('lit-row-','');
                    }
                } else {
                    selectedLit.delete(idx);
                    const row = cb.closest('.lit-row');
                    if (row && row.classList.contains('selected')) {
                        row.classList.remove('selected');
                        selectedLitId = null;
                    }
                }
                updateSelectAll();
            });
        });
        tbody.querySelectorAll('.lit-row').forEach(r => {
            r.addEventListener('click', e => {
                if (e.target.classList.contains('lit-check')) return;
                tbody.querySelectorAll('.lit-row').forEach(x => x.classList.remove('selected'));
                r.classList.add('selected');
                selectedLitId = r.dataset.lid || r.id.replace('lit-row-','');
                const target = document.getElementById(r.dataset.target);
                if (target) {
                    target.style.display = target.style.display === 'none' || !target.style.display ? 'table-row' : 'none';
                }
            });
        });
        updateSelectAll();
    }

    function applyLitFilters() {
        const q = document.getElementById('lit-search').value.trim().toLowerCase();
        const axisVals = Array.from(document.getElementById('lit-axis-filter').selectedOptions).map(o=>o.value).filter(Boolean);
        const constructVals = Array.from(document.getElementById('lit-construct-filter').selectedOptions).map(o=>o.value).filter(Boolean);
        const fieldVals = Array.from(document.getElementById('lit-field-filter').selectedOptions).map(o=>o.value).filter(Boolean);
        let items = literature.filter(l => {
            if (axisVals.length && !axisVals.some(a => (l.axis || '').toLowerCase().includes(a))) return false;
            const catList = Array.isArray(l.category) ? l.category : (l.category || '').split(',').map(c=>c.trim().toLowerCase()).filter(Boolean);
            if (fieldVals.length && !fieldVals.some(f => catList.includes(f))) return false;
            if (constructVals.length) {
                const list = Array.isArray(l.construct) ? l.construct : (l.construct || '').split(/[,;]+/);
                if (!constructVals.some(v => list.some(c => c.trim().toLowerCase() === v))) return false;
            }
            if (q) {
                const authText = Array.isArray(l.authors) ? l.authors.join(' ') : l.authors || '';
                const text = `${l.title || ''} ${authText} ${l.relevance || ''}`.toLowerCase();
                if (!text.includes(q)) return false;
            }
            return true;
        });

        const sortVal = document.getElementById('lit-sort').value;
        if (sortVal === 'title') items.sort((a,b)=>a.title.localeCompare(b.title));
        else if (sortVal === 'author') {
            const getAuth = l => Array.isArray(l.authors) ? l.authors.join(' ') : l.authors || '';
            items.sort((a,b)=>getAuth(a).localeCompare(getAuth(b)));
        }
        else items.sort((a,b)=>(a.year||0)-(b.year||0));
        filteredLiterature = items;
        renderLit(items);
    }

    async function loadLiterature() {
        if (!window.bibtexParse) {
            try {
                const mod = await import('https://cdn.jsdelivr.net/npm/bibtex-parse-js/+esm');
                window.bibtexParse = mod.default || mod;
            } catch (e) {
                console.error('Failed to load BibTeX parser', e);
            }
        }

        let lit = [];
        const useSupabase = window.SUPABASE_URL && window.SUPABASE_ANON_KEY && typeof fetchLiterature === 'function';
        if (useSupabase) {
            for (let i=0; i<20 && !window.supabase && !supabase; i++) await new Promise(r=>setTimeout(r,100));
            if (window.supabase || supabase) {
                try { lit = await fetchLiterature(); } catch(e) { console.error(e); lit = []; }
            }
        } else {
            try { lit = await (await fetch('data/literature.json')).json(); } catch(e) { lit = []; }
        }

        literature = lit.map((l, i) => Object.assign({__index: i}, l));

        const axisSet = new Set();
        const fieldSet = new Set();
        const constructSet = new Set();
        literature.forEach(l => {
            if (l.axis) l.axis.split(',').forEach(a => axisSet.add(a.trim()));
            if (l.category) {
                const cats = Array.isArray(l.category) ? l.category : l.category.split(',');
                cats.forEach(c => fieldSet.add(c.trim().toLowerCase()));
            }
            const list = Array.isArray(l.construct) ? l.construct : (l.construct || '').split(/[,;]+/);
            list.forEach(c => constructSet.add(c.trim()));
        });

        const axisF = document.getElementById('lit-axis-filter');
        const axisOrder = ['sense','explain','respond','adapt','extended'];
        axisOrder.forEach(a => {
            axisF.appendChild(new Option(a.charAt(0).toUpperCase()+a.slice(1), a));
        });
        Array.from(axisSet)
            .filter(a => !axisOrder.includes(a))
            .sort((a,b)=>a.localeCompare(b))
            .forEach(a => axisF.appendChild(new Option(a.charAt(0).toUpperCase()+a.slice(1), a)));

        const fieldF = document.getElementById('lit-field-filter');
        const fieldOrder = ['psychology','philosophy of mind','computer science','ethics','other'];
        fieldOrder.forEach(f => {
            fieldF.appendChild(new Option(toTitle(f), f));
        });
        Array.from(fieldSet)
            .filter(f => !fieldOrder.includes(f))
            .sort((a,b)=>a.localeCompare(b))
            .forEach(f => fieldF.appendChild(new Option(toTitle(f), f)));
        const constructF = document.getElementById('lit-construct-filter');
        Array.from(constructSet)
            .sort((a,b)=>a.toLowerCase().localeCompare(b.toLowerCase()))
            .forEach(c => { if (c) constructF.appendChild(new Option(c, c.toLowerCase())); });

        enableMultiSelectDropdown(axisF);
        enableMultiSelectDropdown(fieldF);
        enableMultiSelectDropdown(constructF);

        document.getElementById('lit-sort').value = 'author';
        applyLitFilters();

        document.getElementById('lit-sort').addEventListener('change', applyLitFilters);
        axisF.addEventListener('change', applyLitFilters);
        fieldF.addEventListener('change', applyLitFilters);
        constructF.addEventListener('change', applyLitFilters);
        document.getElementById('lit-search').addEventListener('input', applyLitFilters);

        document.getElementById('lit-select-all').addEventListener('change', e => {
            document.querySelectorAll('#lit-table tbody .lit-check').forEach(cb => {
                cb.checked = e.target.checked;
                const idx = parseInt(cb.dataset.index, 10);
                if (e.target.checked) selectedLit.add(idx); else selectedLit.delete(idx);
            });
        });

        const bibtexDownloadBtn = document.getElementById('bibtex-download');
        bibtexDownloadBtn?.addEventListener('click', e => {
            e.preventDefault();
            const items = Array.from(selectedLit).map(i => literature.find(l => l.__index === i)).filter(Boolean);
            if (!items.length) return;
            const content = items.map(toBibtex).join('\n\n');
            downloadFile(content, 'references.bib');
        });


        document.getElementById('bibtex-export-filtered').addEventListener('click', e => {
            e.preventDefault();
            const items = filteredLiterature.length ? filteredLiterature : literature;
            if (!items.length) return;
            const content = items.map(toBibtex).join('\n\n');
            downloadFile(content, 'references.bib');
        });

    }

document.addEventListener('DOMContentLoaded', loadLiterature);
let authed = false;

async function startBibtex() {
    if (!authed) { if (!(await authenticate())) return; authed = true; }
    const formHtml = `<form id="bibtex-form">
        <label>Upload .bib <input id="bibtex-file" type="file" accept=".bib"></label>
        <label>Or paste BibTeX:<br><textarea id="bibtex-text" rows="10" style="width:100%"></textarea></label>
        <div class="edit-buttons">
            <button type="submit" class="button">Import</button>
            <button type="button" id="bibtex-cancel" class="button">Cancel</button>
        </div>
    </form>`;
    const form = showEditOverlay(formHtml);
    const fileInput = form.querySelector('#bibtex-file');
    form.addEventListener('submit', async e => {
        e.preventDefault();
        let text = form.querySelector('#bibtex-text').value;
        if (!text.trim() && fileInput.files[0]) {
            text = await fileInput.files[0].text();
        }
        hideEditOverlay();
        if (!text.trim()) { showToast('No BibTeX provided'); return; }
        const entries = parseBibtex(text);
        const titles = new Set(literature.map(l => (l.title || '').toLowerCase()));
        const dois = new Set(literature.map(l => (l.url || '').replace(/https?:\/(dx\.)?doi.org\//i, '').toLowerCase()));
        let maxIndex = Math.max(0, ...literature.map(l => l.__index || 0));
        let added = 0;
        for (const en of entries) {
            const t = (en.title || '').toLowerCase();
            const d = (en.doi || en.url || '').replace(/https?:\/(dx\.)?doi.org\//i, '').toLowerCase();
            if (titles.has(t) || (d && dois.has(d))) continue;
            const obj = Object.assign({construct: '', axis: '', methodology_supported: '', relevance: ''}, en);
            if (!obj.construct) {
                const v = prompt(`Construct for "${obj.title}"?`);
                if (v !== null) obj.construct = v.trim();
            }
            if (!obj.axis) {
                const v = prompt(`Axis for "${obj.title}"?`);
                if (v !== null) obj.axis = v.trim();
            }
            if (!obj.methodology_supported) {
                const v = prompt(`Methodology supported for "${obj.title}"?`);
                if (v !== null) obj.methodology_supported = v.trim();
            }
            obj.__index = ++maxIndex;
            if (authed && typeof addLiterature === 'function') {
                try {
                    const { data, error } = await addLiterature(obj);
                    if (!error && data && data[0]) Object.assign(obj, data[0]);
                } catch (err) { console.error(err); }
            }
            literature.push(obj);
            titles.add(t);
            if (d) dois.add(d);
            added++;
        }
        applyLitFilters();
        showToast(added ? `${added} entries added` : 'No new entries added');
    });
    form.querySelector('#bibtex-cancel').addEventListener('click', hideEditOverlay);
}

async function startAddLit() {
    if (!authed) { if (!(await authenticate())) return; authed = true; }
    document.getElementById('lit-add-row')?.remove();
    const tbody = document.querySelector('#lit-table tbody');
    const addRow = document.createElement('tr');
    addRow.id = 'lit-add-row';
    addRow.innerHTML = `<td colspan="8"><form id="lit-add-form">
        <label>Title: <input type="text" name="title" required></label>
        <div id="authors-container">
            <label>Author 1: <input type="text" class="author-input"></label>
        </div>
        <button type="button" id="add-author-btn" class="button">Add another author</button>
        <label>Year: <input type="number" name="year"></label>
        <label>Publisher: <input type="text" name="publisher"></label>
        <label>Journal: <input type="text" name="journal"></label>
        <label>Volume: <input type="number" name="volume" inputmode="numeric" pattern="\d*"></label>
        <label>Number: <input type="number" name="number" inputmode="numeric" pattern="\d*"></label>
        <label>Pages: <input type="text" name="pages" pattern="[1-9]\d{0,3}(?:-{1,2}[1-9]\d{0,3})?" title="e.g., 123-145 or 123--145"></label>
        <label>URL: <input type="text" name="url"></label>
        <label>Category: <select name="category" multiple size="1">
            <option value="psychology">Psychology</option>
            <option value="philosophy of mind">Philosophy of Mind</option>
            <option value="computer science">Computer Science</option>
            <option value="ethics">Ethics</option>
            <option value="other">Other</option>
        </select></label>
        <label>Keywords: <input type="text" name="keywords" placeholder="comma separated"></label>
        <label>Construct: <input type="text" name="construct"></label>
        <label>Axis: <select name="axis" multiple size="1">
            <option value="sense">Sense</option>
            <option value="explain">Explain</option>
            <option value="respond">Respond</option>
            <option value="adapt">Adapt</option>
            <option value="extended">Extended</option>
        </select></label>
        <label>Methodology Supported: <input type="text" name="methodology_supported"></label>
        <label>Relevance: <textarea name="relevance" rows="3"></textarea></label>
        <button type="submit">Add</button>
        <button type="button" id="lit-add-cancel">Cancel</button>
        <div class="form-error" style="display:none"></div>
    </form></td>`;
    tbody.prepend(addRow);
    const form = document.getElementById('lit-add-form');
    const errorDiv = form.querySelector('.form-error');
    enableMultiSelectDropdown(form.elements.axis);
    enableMultiSelectDropdown(form.elements.category);
    const authorsContainer = form.querySelector('#authors-container');
    const addAuthorBtn = form.querySelector('#add-author-btn');
    addAuthorBtn.addEventListener('click', () => {
        const count = authorsContainer.querySelectorAll('.author-input').length;
        if (count >= 10) return;
        const label = document.createElement('label');
        label.textContent = `Author ${count + 1}: `;
        const input = document.createElement('input');
        input.type = 'text';
        input.className = 'author-input';
        label.appendChild(input);
        authorsContainer.appendChild(label);
    });
    form.addEventListener('submit', async e => {
        e.preventDefault();
        errorDiv.textContent = '';
        errorDiv.style.display = 'none';
        if (!authed) { if (!(await authenticate())) return; authed = true; }
        const axisArr = Array.from(form.elements.axis.selectedOptions).map(o => o.value);
        const catArr = Array.from(form.elements.category.selectedOptions).map(o => o.value);
        const constructVal = e.target.construct.value.trim();
        const methVal = e.target.methodology_supported.value.trim();
        if (axisArr.length === 0 && !constructVal && !methVal) {
            alert('Please specify at least one of Axis, Construct, or Methodology Supported.');
            return;
        }
        const authorArr = Array.from(form.querySelectorAll('.author-input'))
            .map(i => toTitleCase(i.value.trim()))
            .filter(Boolean);
        const obj = {
            title: toTitleCase(e.target.title.value.trim()),
            authors: authorArr,
            year: parseInt(e.target.year.value,10) || null,
            publisher: e.target.publisher.value,
            journal: e.target.journal.value,
            volume: parseInt(e.target.volume.value,10) || null,
            number: parseInt(e.target.number.value,10) || null,
            pages: e.target.pages.value,
            url: e.target.url.value,
            category: catArr.join(', '),
            keywords: e.target.keywords.value.split(',').map(s=>s.trim()).filter(Boolean),
            construct: e.target.construct.value,
            axis: axisArr,
            methodology_supported: e.target.methodology_supported.value,
            relevance: e.target.relevance.value
        };
        const titleLower = obj.title.trim().toLowerCase();
        const doiLower = (obj.url || '').replace(/https?:\/(?:dx\.)?doi.org\//i, '').toLowerCase();
        const exists = literature.some(l => {
            const t = (l.title || '').trim().toLowerCase();
            const d = (l.url || '').replace(/https?:\/(?:dx\.)?doi.org\//i, '').toLowerCase();
            return t === titleLower || (doiLower && d === doiLower);
        });
        if (exists) {
            alert('This entry already exists.');
            return;
        }
        if (typeof addLiterature === 'function') {
            try {
                const { data, error } = await addLiterature(obj);
                if (error) {
                    errorDiv.textContent = error.message || error;
                    errorDiv.style.display = 'block';
                    return;
                }
                if (data && data[0]) Object.assign(obj, data[0]);
            } catch (err) {
                console.error(err);
                errorDiv.textContent = err.message || err;
                errorDiv.style.display = 'block';
                return;
            }
        }
        obj.axis = axisArr.join(', ');
        obj.__index = Math.max(0, ...literature.map(l => l.__index || 0)) + 1;
        literature.push(obj);
        addRow.remove();
        applyLitFilters();
        showToast('Entry added');
        lastLitAction = { type: 'add', item: obj, index: literature.length - 1 };
    });
    document.getElementById('lit-add-cancel').addEventListener('click', () => {
        addRow.remove();
    });
}

async function startEditLit() {
    if (!authed) { if (!(await authenticate())) return; authed = true; }
    if (selectedLitId === null) { alert('Select an entry first.'); return; }
    const item = literature.find(l => (l.id ?? l.__index) == selectedLitId);
    if (!item) return;
    const axisVals = Array.isArray(item.axis) ? item.axis : (item.axis || '').split(',').map(a=>a.trim());
    let authorsVal;
    if (Array.isArray(item.authors)) {
        authorsVal = item.authors;
    } else {
        const raw = String(item.authors || '').trim();
        try {
            const parsed = JSON.parse(raw);
            if (Array.isArray(parsed)) authorsVal = parsed;
        } catch (_) {}
        if (!authorsVal) {
            authorsVal = raw.split(/\s+and\s+|;|,/).map(a => a.trim()).filter(Boolean);
        }
    }
    const originalAuthors = authorsVal.map(a => toTitleCase(a));
    const authorsInputs = (authorsVal.length ? authorsVal : ['']).map((a,i)=>`<label>Author ${i+1}: <input type="text" class="author-input" value="${a}"></label>`).join('');
    const formHtml = `<form id="lit-edit-form">
        <label>Title: <input type="text" name="title" value="${item.title}" placeholder="Paper title"></label>
        <div id="authors-container">${authorsInputs}</div>
        <button type="button" id="add-author-btn" class="button">Add another author</button>
        <label>Year: <input type="number" name="year" value="${item.year || ''}" placeholder="2024"></label>
        <label>Publisher: <input type="text" name="publisher" value="${item.publisher || ''}" placeholder="Publisher"></label>
        <label>Journal: <input type="text" name="journal" value="${item.journal || ''}" placeholder="Journal name"></label>
        <label>Volume: <input type="number" name="volume" value="${item.volume || ''}" placeholder="Volume" inputmode="numeric" pattern="\d*"></label>
        <label>Number: <input type="number" name="number" value="${item.number || ''}" placeholder="Number" inputmode="numeric" pattern="\d*"></label>
        <label>Pages: <input type="text" name="pages" value="${item.pages || ''}" placeholder="Pages" pattern="[1-9]\d{0,3}(?:-{1,2}[1-9]\d{0,3})?" title="e.g., 123-145 or 123--145"></label>
        <label>URL: <input type="url" name="url" value="${item.url || ''}" placeholder="https://..."></label>
        <label>Category: <select name="category" multiple size="1">
            <option value="psychology" ${item.category && item.category.toLowerCase().includes('psychology') ? 'selected' : ''}>Psychology</option>
            <option value="philosophy of mind" ${item.category && item.category.toLowerCase().includes('philosophy of mind') ? 'selected' : ''}>Philosophy of Mind</option>
            <option value="computer science" ${item.category && item.category.toLowerCase().includes('computer science') ? 'selected' : ''}>Computer Science</option>
            <option value="ethics" ${item.category && item.category.toLowerCase().includes('ethics') ? 'selected' : ''}>Ethics</option>
            <option value="other" ${item.category && item.category.toLowerCase().includes('other') ? 'selected' : ''}>Other</option>
        </select></label>
        <label>Keywords: <input type="text" name="keywords" value="${Array.isArray(item.keywords) ? item.keywords.join(', ') : (item.keywords || '')}" placeholder="comma separated"></label>
        <label>Axis: <select name="axis" multiple size="1">
            <option value="sense" ${axisVals.includes('sense') ? 'selected' : ''}>Sense</option>
            <option value="explain" ${axisVals.includes('explain') ? 'selected' : ''}>Explain</option>
            <option value="respond" ${axisVals.includes('respond') ? 'selected' : ''}>Respond</option>
            <option value="adapt" ${axisVals.includes('adapt') ? 'selected' : ''}>Adapt</option>
            <option value="extended" ${axisVals.includes('extended') ? 'selected' : ''}>Extended</option>
        </select></label>
        <label>Methodology Supported: <input type="text" name="methodology_supported" value="${item.methodology_supported || ''}"></label>
        <label>Relevance: <textarea name="relevance" rows="3">${item.relevance || ''}</textarea></label>
        <div class="edit-buttons">
            <button type="submit" class="button">Save</button>
            <button type="button" id="lit-edit-cancel" class="button">Cancel</button>
        </div>
    </form>`;
    const form = showEditOverlay(formHtml);
    enableMultiSelectDropdown(form.elements.axis);
    enableMultiSelectDropdown(form.elements.category);
    const authorsContainerE = form.querySelector('#authors-container');
    const addAuthorBtnE = form.querySelector('#add-author-btn');
    addAuthorBtnE.addEventListener('click', () => {
        const count = authorsContainerE.querySelectorAll('.author-input').length;
        if (count >= 10) return;
        const label = document.createElement('label');
        label.textContent = `Author ${count + 1}: `;
        const input = document.createElement('input');
        input.type = 'text';
        input.className = 'author-input';
        label.appendChild(input);
        authorsContainerE.appendChild(label);
    });
    form.addEventListener('submit', async e => {
        e.preventDefault();
        if (!authed) { if (!(await authenticate())) return; authed = true; }
        if (!confirm('Save changes?')) return;
        const before = JSON.parse(JSON.stringify(item));
        item.title = toTitleCase(form.title.value.trim());
        const authorInputs = Array.from(form.querySelectorAll('.author-input'))
            .map(i => toTitleCase(i.value.trim()));
        const newAuthors = authorInputs.filter(Boolean);
        const authorsModified =
            authorInputs.length !== originalAuthors.length ||
            authorInputs.some((a, idx) => a !== originalAuthors[idx]);
        if (authorsModified) {
            item.authors = newAuthors;
        }
        item.year = parseInt(form.year.value,10) || null;
        item.publisher = form.publisher.value;
        item.journal = form.journal.value;
        item.volume = parseInt(form.volume.value,10) || null;
        item.number = parseInt(form.number.value,10) || null;
        item.pages = form.pages.value;
        item.url = form.url.value;
        const catArrEdit = Array.from(form.elements.category.selectedOptions).map(o => o.value);
        item.category = catArrEdit.join(', ');
        item.keywords = form.keywords.value.split(',').map(s=>s.trim()).filter(Boolean);
        const axisArr = Array.from(form.elements.axis.selectedOptions).map(o => o.value);
        item.axis = axisArr.join(', ');
        item.methodology_supported = form.methodology_supported.value;
        item.relevance = form.relevance.value;
        if (item.id && typeof updateLiterature === 'function') await updateLiterature(item.id, {
            title: item.title,
            authors: item.authors,
            year: item.year,
            publisher: item.publisher,
            journal: item.journal,
            volume: item.volume,
            number: item.number,
            pages: item.pages,
            url: item.url,
            category: item.category,
            keywords: item.keywords,
            axis: axisArr,
            methodology_supported: item.methodology_supported,
            relevance: item.relevance
        });
        hideEditOverlay();
        applyLitFilters();
        showToast('Entry updated');
        lastLitAction = { type: 'update', item, before };
    });
    document.getElementById('lit-edit-cancel').addEventListener('click', hideEditOverlay);
}

async function deleteSelectedLit() {
    if (selectedLitId === null) { alert('Select an entry first.'); return; }
    const idx = literature.findIndex(l => (l.id ?? l.__index) == selectedLitId);
    if (idx === -1) return;
    if (!authed) { if (!(await authenticate())) return; authed = true; }
    if (!confirm('Delete this entry?')) return;
    const item = literature[idx];
    if (item.id && typeof deleteLiterature === 'function') await deleteLiterature(item.id);
    const removed = literature.splice(idx,1)[0];
    selectedLitId = null;
    applyLitFilters();
    lastLitAction = { type: 'delete', item: removed, index: idx };
}

async function undoLastLitAction() {
    if (!lastLitAction) { alert('Nothing to undo'); return; }
    const { type, item, index, before } = lastLitAction;
    if (type === 'add') {
        if (item.id && typeof deleteLiterature === 'function') await deleteLiterature(item.id);
        const idx = literature.findIndex(l => l === item || (l.id ?? l.__index) == (item.id ?? item.__index));
        if (idx !== -1) literature.splice(idx,1);
    } else if (type === 'update') {
        Object.assign(item, before);
        if (item.id && typeof updateLiterature === 'function') await updateLiterature(item.id, before);
    } else if (type === 'delete') {
        if (typeof addLiterature === 'function') {
            const { data } = await addLiterature(item);
            if (data && data[0]) item.id = data[0].id;
        }
        literature.splice(index,0,item);
    }
    applyLitFilters();
    lastLitAction = null;
}



document.getElementById('edit-lit-btn').addEventListener('click', startEditLit);
document.getElementById('delete-lit-btn').addEventListener('click', deleteSelectedLit);
document.getElementById('add-source-btn').addEventListener('click', startAddLit);
document.getElementById('bibtex-btn').addEventListener('click', startBibtex);
document.getElementById('undo-lit-btn').addEventListener('click', undoLastLitAction);

// Confirm before saving new or updated literature
document.getElementById('literature-form')?.addEventListener('submit', e => {
    if (!confirm('Save changes?')) {
        e.preventDefault();
    }
});
    </script>
    <script src="env.js"></script>
    <script src="script.js"></script>
</body>
</html>
