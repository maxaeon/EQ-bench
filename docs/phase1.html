<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI EQ - Phase 1</title>
    <link rel="stylesheet" href="style.css">
    <link rel="icon" href="assets/images/favicon.png">
</head>
<body>
    <a class="skip-link" href="#main">Skip to main content</a>
    <header>
        <h1><a class="logo" href="#" id="logo-link">AI EQ Benchmark Framework</a></h1>
        <div id="logo-menu" class="logo-menu">
            <ul>
                <li><a href="index.html">Home</a></li>
                <li><a href="expert-collaborators.html">Our Team of Experts</a></li>
                <li>
                    <a href="research.html">Project Development</a>
                    <ul>
                        <li><a href="phase1.html">Phase 1</a></li>
                    </ul>
                </li>
                <li><a href="https://github.com/maxaeon/EQ-bench">GitHub Repository</a></li>
            </ul>
        </div>
        <button class="nav-toggle" aria-label="Toggle navigation">&#9776;</button>
        <nav class="site-nav" aria-label="Primary">
            <ul>
                <li><a href="sense.html">Sense</a></li>
                <li><a href="explain.html">Explain</a></li>
                <li><a href="respond.html">Respond</a></li>
                <li><a href="adapt.html">Adapt</a></li>
                <li><a href="extended.html">Extended</a></li>
            </ul>
        </nav>
    </header>
    <main id="main" class="wide">
        <section id="contribute">
            <h1>Phase 1: Framework Feedback and Literature Scan</h1>
            <hr>
            <h2>Axis Feedback</h2>
            <p>We are gathering input on the proposed SERA-X axes and compiling relevant peerâ€‘reviewed literature. As an introductory project, contributors and collaborators are encouraged to familiarize themselves with existing emotional intelligence benchmarking frameworks. Please review our detailed comparison here:</p>
            <p><a href="alternative-models.html"><strong>Comparison of Alternative Emotional Intelligence Models</strong></a></p>
            <p>Please explore the references below. Editing is currently open so you can add or update sources directly in our Supabase database. For broader comments on the SERA-X framework, let us know via our feedback form.</p>
        </section>


        <section id="literature">
            <hr>
            <h2>Relevant Literature</h2>
            <p>Notice something missing? Use the <strong>Add Source</strong> button to submit new references. You may also import a <code>.bib</code> file and the entries will be saved to our Supabase database. Login is temporarily disabled.</p>
            <div class="add-source-controls">
                <label for="bib-upload" class="button">Upload .bib</label>
                <input id="bib-upload" type="file" accept=".bib" hidden>
                <button id="add-source-btn" class="button" type="button">Add Source</button>
            </div>

            <div class="search-controls">
                <label for="lit-search">Search:</label>
                <input type="search" id="lit-search" placeholder="Search literature">
            </div>
            
            <div class="controls-row">
                <div class="filter-controls">
                    <label for="lit-axis-filter">Axis:</label>
                    <select id="lit-axis-filter" multiple size="1">
                        <option value="">All</option>
                    </select>
                    <label for="lit-construct-filter">Construct:</label>
                    <select id="lit-construct-filter" multiple size="1">
                        <option value="">All</option>
                    </select>
                    <label for="lit-field-filter">Field/Topic:</label>
                    <select id="lit-field-filter" multiple size="1">
                        <option value="">All</option>
                    </select>
                </div>
                <div class="sort-controls">
                    <label for="lit-sort">Sort by:</label>
                    <select id="lit-sort">
                        <option value="year">Year</option>
                        <option value="author">Author</option>
                        <option value="title">Title</option>
                    </select>
                </div>
            </div>
            <div class="table-scroll">
            <table id="lit-table">
                <thead>
                    <tr>
                        <th><input type="checkbox" id="lit-select-all"></th>
                        <th>Title</th>
                        <th>Author(s)</th>
                        <th>Year</th>
                        <th>Relevance</th>
                        <th>Construct</th>
                        <th>Axis</th>
                        <th>Avg Rating <span class="info-icon" title="1 star = not relevant, 5 stars = crucial">?</span></th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
            </div>
        </section>
        <div class="bibtex-controls">
            <a class="button" href="#" id="bibtex-download">Download BibTeX</a>
            <button id="edit-lit-btn" class="button">Edit</button>
            <button id="delete-lit-btn" class="button">Delete</button>
        </div>

            <hr style="margin-top: 40px; margin-bottom: 20px;">

            <div style="padding:20px; background-color:#f9f9f9; border-radius:8px; border: 1px solid #ddd;">
              <hr>
              <h2>Collaborative Literature Review</h2>
              <p>
                We encourage all contributors to help build our interdisciplinary literature review directly in our shared Overleaf project. Your input is essential in identifying and synthesizing relevant sources from philosophy, psychology, neuroscience, and computer science.
              </p>
              <p style="margin-top:15px;">
                ðŸ”— <a href="https://www.overleaf.com/4957755681mcqwpwkcyjrq#be11ce" target="_blank" style="font-weight:bold; color:#0066cc;">Access the collaborative Overleaf document here</a>
              </p>
              <p style="font-size: 0.9em; color: #666;">
                (No Overleaf account is required to view or edit. Please add brief summaries, relevant references, and foundational resources.)
              </p>
            </div>

<section>
    <h2>Manage Submissions</h2>
    <p>You can edit or delete literature records without logging in.</p>
</section>
    </main>
    <footer>
        <p>&copy; Inflection AI Research Collaborative</p>
    </footer>
    <script>

    let literature = [];

    function toTitle(text) {
        return text.replace(/(^|\s)\S/g, t => t.toUpperCase());
    }

    const selectedLit = new Set();
    let selectedLitId = null;

    function toBibtex(item) {
        const type = item.journal ? 'article' : 'book';
        const keyAuthor = (item.authors || 'ref').split(/[ ,]/)[0].replace(/[^a-zA-Z0-9]/g, '');
        const key = keyAuthor + (item.year || '');
        let entry = `@${type}{${key},\n  title = {${item.title}}`;
        if (item.authors) entry += `,\n  author = {${item.authors}}`;
        if (item.journal) entry += `,\n  journal = {${item.journal}}`;
        if (item.publisher) entry += `,\n  publisher = {${item.publisher}}`;
        if (item.address) entry += `,\n  address = {${item.address}}`;
        if (item.volume) entry += `,\n  volume = {${item.volume}}`;
        if (item.number) entry += `,\n  number = {${item.number}}`;
        if (item.pages) entry += `,\n  pages = {${item.pages}}`;
        if (item.year) entry += `,\n  year = {${item.year}}`;
        if (item.url) entry += `,\n  url = {${item.url}}`;
        entry += `\n}`;
        return entry;
    }

    function downloadFile(content, filename) {
        const blob = new Blob([content], {type: 'text/x-bibtex'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        URL.revokeObjectURL(url);
        a.remove();
    }

    function updateSelectAll() {
        const cbs = document.querySelectorAll('#lit-table tbody .lit-check');
        const allChecked = cbs.length && Array.from(cbs).every(cb => cb.checked);
        document.getElementById('lit-select-all').checked = allChecked;
    }




    function renderLit(items) {
        const tbody = document.querySelector('#lit-table tbody');
        tbody.innerHTML = '';
        items.forEach(l => {
            const checked = selectedLit.has(l.__index) ? 'checked' : '';
            const row = document.createElement('tr');
            row.className = 'lit-row';
            row.dataset.lid = l.id ?? l.__index;
            row.id = `lit-row-${l.id ?? l.__index}`;
            row.innerHTML = `
                <td><input type="checkbox" class="lit-check" data-index="${l.__index}" ${checked}></td>
                <td>${l.title}</td>
                <td>${l.authors}</td>
                <td>${l.year}</td>
                <td>${l.relevance || ''}</td>
                <td>${(Array.isArray(l.construct) ? l.construct : (l.construct || '').split(/[,;]+/)).map(c => c.trim()).filter(Boolean).join('<br>')}</td>
                <td>${l.axis}</td>
                <td><span class="avg-rating" data-index="${l.__index}"></span> <div class="star-rating lit-rating" data-index="${l.__index}"></div></td>`;
            tbody.appendChild(row);
        });
        tbody.querySelectorAll('.lit-check').forEach(cb => {
            cb.addEventListener('change', () => {
                const idx = parseInt(cb.dataset.index, 10);
                if (cb.checked) selectedLit.add(idx); else selectedLit.delete(idx);
                updateSelectAll();
            });
        });
        tbody.querySelectorAll('.lit-row').forEach(r => {
            r.addEventListener('click', e => {
                if (e.target.classList.contains('lit-check') || e.target.closest('.star-rating')) return;
                tbody.querySelectorAll('.lit-row').forEach(x => x.classList.remove('selected'));
                r.classList.add('selected');
                selectedLitId = r.dataset.lid || r.id.replace('lit-row-','');
            });
        });
        updateSelectAll();
        initRatings('.lit-rating', 'lit-rating', idx => literature.find(l => l.__index == idx));
    }

    function applyLitFilters() {
        const q = document.getElementById('lit-search').value.trim().toLowerCase();
        const axisVals = Array.from(document.getElementById('lit-axis-filter').selectedOptions).map(o=>o.value).filter(Boolean);
        const constructVals = Array.from(document.getElementById('lit-construct-filter').selectedOptions).map(o=>o.value).filter(Boolean);
        const fieldVals = Array.from(document.getElementById('lit-field-filter').selectedOptions).map(o=>o.value).filter(Boolean);
        let items = literature.filter(l => {
            if (axisVals.length && !axisVals.some(a => (l.axis || '').toLowerCase().includes(a))) return false;
            if (fieldVals.length && !fieldVals.some(f => (l.category || '').toLowerCase().includes(f))) return false;
            if (constructVals.length) {
                const list = Array.isArray(l.construct) ? l.construct : (l.construct || '').split(/[,;]+/);
                if (!constructVals.some(v => list.some(c => c.trim().toLowerCase() === v))) return false;
            }
            if (q) {
                const text = `${l.title || ''} ${l.authors || ''} ${l.relevance || ''}`.toLowerCase();
                if (!text.includes(q)) return false;
            }
            return true;
        });

        const sortVal = document.getElementById('lit-sort').value;
        if (sortVal === 'title') items.sort((a,b)=>a.title.localeCompare(b.title));
        else if (sortVal === 'author') items.sort((a,b)=>a.authors.localeCompare(b.authors));
        else items.sort((a,b)=>(a.year||0)-(b.year||0));
        renderLit(items);
    }

    async function loadLiterature() {
        let lit = [];
        const useSupabase = window.SUPABASE_URL && window.SUPABASE_ANON_KEY && typeof fetchLiterature === 'function';
        if (useSupabase) {
            for (let i=0; i<20 && !window.supabase && !supabase; i++) await new Promise(r=>setTimeout(r,100));
            if (window.supabase || supabase) {
                try { lit = await fetchLiterature(); } catch(e) { console.error(e); lit = []; }
            }
        } else {
            try { lit = await (await fetch('data/literature.json')).json(); } catch(e) { lit = []; }
        }

        literature = lit.map((l, i) => Object.assign({__index: i, ratings: l.ratings || []}, l));

        const axisSet = new Set();
        const fieldSet = new Set();
        const constructSet = new Set();
        literature.forEach(l => {
            if (l.axis) l.axis.split(',').forEach(a => axisSet.add(a.trim()));
            if (l.category) fieldSet.add(l.category.trim().toLowerCase());
            const list = Array.isArray(l.construct) ? l.construct : (l.construct || '').split(/[,;]+/);
            list.forEach(c => constructSet.add(c.trim()));
        });

        const axisF = document.getElementById('lit-axis-filter');
        const axisOrder = ['sense','explain','respond','adapt','extended'];
        axisOrder.forEach(a => { if (axisSet.has(a)) axisF.appendChild(new Option(a.charAt(0).toUpperCase()+a.slice(1), a)); });
        const fieldF = document.getElementById('lit-field-filter');
        const fieldOrder = ['philosophy and ethics','psychology','computer science','neuroscience','other'];
        fieldOrder.forEach(f => { if (fieldSet.has(f)) fieldF.appendChild(new Option(toTitle(f), f)); });
        const constructF = document.getElementById('lit-construct-filter');
        Array.from(constructSet)
            .sort((a,b)=>a.toLowerCase().localeCompare(b.toLowerCase()))
            .forEach(c => { if (c) constructF.appendChild(new Option(c, c.toLowerCase())); });

        enableMultiSelectDropdown(axisF);
        enableMultiSelectDropdown(fieldF);
        enableMultiSelectDropdown(constructF);

        document.getElementById('lit-sort').value = 'author';
        applyLitFilters();

        document.getElementById('lit-sort').addEventListener('change', applyLitFilters);
        axisF.addEventListener('change', applyLitFilters);
        fieldF.addEventListener('change', applyLitFilters);
        constructF.addEventListener('change', applyLitFilters);
        document.getElementById('lit-search').addEventListener('input', applyLitFilters);

        document.getElementById('lit-select-all').addEventListener('change', e => {
            document.querySelectorAll('#lit-table tbody .lit-check').forEach(cb => {
                cb.checked = e.target.checked;
                const idx = parseInt(cb.dataset.index, 10);
                if (e.target.checked) selectedLit.add(idx); else selectedLit.delete(idx);
            });
        });

        document.getElementById('bibtex-download').addEventListener('click', e => {
            e.preventDefault();
            const items = Array.from(selectedLit).map(i => literature.find(l => l.__index === i)).filter(Boolean);
            if (!items.length) return;
            const content = items.map(toBibtex).join('\n\n');
            downloadFile(content, 'references.bib');
        });

        document.getElementById('bib-upload').addEventListener('change', e => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = async () => {
                const entries = parseBibtex(reader.result);
                const titles = new Set(literature.map(l => (l.title || '').toLowerCase()));
                const dois = new Set(literature.map(l => (l.url || '').replace(/https?:\/\/(dx\.)?doi.org\//i, '').toLowerCase()));
                let maxIndex = Math.max(0, ...literature.map(l => l.__index || 0));
                for (const en of entries) {
                    const t = (en.title || '').toLowerCase();
                    const d = (en.doi || en.url || '').replace(/https?:\/\/(dx\.)?doi.org\//i, '').toLowerCase();
                    if (titles.has(t) || (d && dois.has(d))) continue;
                    const obj = Object.assign({construct: '', axis: '', relevance: '', ratings: []}, en);
                    obj.__index = ++maxIndex;
                    if (authed && typeof addLiterature === 'function') {
                        try {
                            const res = await addLiterature(obj);
                            if (res && res[0]) Object.assign(obj, res[0]);
                        } catch (err) { console.error(err); }
                    }
                    literature.push(obj);
                    titles.add(t);
                    if (d) dois.add(d);
                }
                applyLitFilters();
                e.target.value = '';
            };
            reader.readAsText(file);
        });
    }

document.addEventListener('DOMContentLoaded', loadLiterature);
let authed = true;

function startAddLit() {
    document.getElementById('lit-add-row')?.remove();
    const tbody = document.querySelector('#lit-table tbody');
    const addRow = document.createElement('tr');
    addRow.id = 'lit-add-row';
    addRow.innerHTML = `<td colspan="8"><form id="lit-add-form">
        <label>Title: <input type="text" name="title" required></label>
        <label>Authors: <input type="text" name="authors"></label>
        <label>Year: <input type="number" name="year"></label>
        <label>Construct: <input type="text" name="construct"></label>
        <label>Axis: <input type="text" name="axis"></label>
        <label>Relevance:<br><textarea name="relevance" rows="3"></textarea></label>
        <button type="submit">Add</button>
        <button type="button" id="lit-add-cancel">Cancel</button>
    </form></td>`;
    tbody.prepend(addRow);
    document.getElementById('lit-add-form').addEventListener('submit', async e => {
        e.preventDefault();
        if (!authed) { if (!(await authenticate())) return; authed = true; }
        const obj = {
            title: e.target.title.value,
            authors: e.target.authors.value,
            year: parseInt(e.target.year.value,10) || null,
            construct: e.target.construct.value,
            axis: e.target.axis.value,
            relevance: e.target.relevance.value,
            ratings: []
        };
        if (typeof addLiterature === 'function') {
            try {
                const res = await addLiterature(obj);
                if (res && res[0]) Object.assign(obj, res[0]);
            } catch (err) { console.error(err); }
        }
        obj.__index = Math.max(0, ...literature.map(l => l.__index || 0)) + 1;
        literature.push(obj);
        addRow.remove();
        applyLitFilters();
    });
    document.getElementById('lit-add-cancel').addEventListener('click', () => addRow.remove());
}

function startEditLit() {
    if (selectedLitId === null) { alert('Select an entry first.'); return; }
    const item = literature.find(l => (l.id ?? l.__index) == selectedLitId);
    if (!item) return;
    const row = document.getElementById('lit-row-' + selectedLitId);
    document.getElementById('lit-edit-row')?.remove();
    const editRow = document.createElement('tr');
    editRow.id = 'lit-edit-row';
    editRow.innerHTML = `<td colspan="8"><form id="lit-edit-form">
        <label>Title: <input type="text" name="title" value="${item.title}"></label>
        <label>Authors: <input type="text" name="authors" value="${item.authors || ''}"></label>
        <label>Year: <input type="number" name="year" value="${item.year || ''}"></label>
        <button type="submit">Save</button>
        <button type="button" id="lit-edit-cancel">Cancel</button>
    </form></td>`;
    row.insertAdjacentElement('afterend', editRow);
    document.getElementById('lit-edit-form').addEventListener('submit', async e => {
        e.preventDefault();
        if (!authed) { if (!(await authenticate())) return; authed = true; }
        if (!confirm('Save changes?')) return;
        item.title = e.target.title.value;
        item.authors = e.target.authors.value;
        item.year = parseInt(e.target.year.value,10) || null;
        if (item.id && typeof updateLiterature === 'function') await updateLiterature(item.id, {title:item.title, authors:item.authors, year:item.year});
        editRow.remove();
        applyLitFilters();
    });
    document.getElementById('lit-edit-cancel').addEventListener('click', () => editRow.remove());
}

async function deleteSelectedLit() {
    if (selectedLitId === null) { alert('Select an entry first.'); return; }
    const idx = literature.findIndex(l => (l.id ?? l.__index) == selectedLitId);
    if (idx === -1) return;
    if (!authed) { if (!(await authenticate())) return; authed = true; }
    if (!confirm('Delete this entry?')) return;
    const item = literature[idx];
    if (item.id && typeof deleteLiterature === 'function') await deleteLiterature(item.id);
    literature.splice(idx,1);
    selectedLitId = null;
    applyLitFilters();
}



document.getElementById('edit-lit-btn').addEventListener('click', startEditLit);
document.getElementById('delete-lit-btn').addEventListener('click', deleteSelectedLit);
document.getElementById('add-source-btn').addEventListener('click', startAddLit);

// Confirm before saving new or updated literature
document.getElementById('literature-form')?.addEventListener('submit', e => {
    if (!confirm('Save changes?')) {
        e.preventDefault();
    }
});
    </script>
    <script src="env.js"></script>
    <script src="script.js"></script>
</body>
</html>
