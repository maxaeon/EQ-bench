<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EQ AI Research Hub - Phase 1</title>
    <link rel="stylesheet" href="style.css">
    <link rel="icon" href="assets/images/favicon.png">
</head>
<body>
    <a class="skip-link" href="#main">Skip to main content</a>
    <header>
        <nav class="site-nav main-menu" aria-label="Primary">
            <button class="nav-toggle" aria-label="Toggle navigation">&#9776;</button>
            <ul>
                <li><a href="index.html">EQ AI Research Hub</a></li>
                <li class="dropdown">
                    <a href="research.html">Our Research Project</a>
                    <ul>
                        <li><a href="phase1.html">Phase 1</a></li>
                        <li><a href="phase2.html">Phase 2</a></li>
                        <li><a href="phase3.html">Phase 3</a></li>
                        <li><a href="phase4.html">Phase 4</a></li>
                    </ul>
                </li>
                <li><a href="expert-collaborators.html">Our Team of Experts</a></li>
                <li><a href="https://github.com/maxaeon/EQ-bench">GitHub Repository</a></li>
            </ul>
        </nav>

    </header>
    <main id="main" class="wide">
        <section id="contribute">
            <h1>Phase 1: Framework Feedback and Literature Scan</h1>
            <hr>
            <h2>Axis Feedback</h2>
            <p>We are gathering input on the proposed SERA-X axes and compiling relevant peerâ€‘reviewed literature. As an introductory project, contributors and collaborators are encouraged to familiarize themselves with existing emotional intelligence benchmarking frameworks. Please review our detailed comparison here:</p>
            <p><a href="alternative-models.html"><strong>Comparison of Alternative Emotional Intelligence Models</strong></a></p>
<p>For an overview of the SERA-X axes, see the <a href="axes.html">SERA-X Axes page</a>.</p>
            <p>Please explore the references below. Editing is currently open so you can add or update sources directly in our Supabase database. For broader comments on the SERA-X framework, let us know via our feedback form.</p>
        </section>


        <section id="literature">
            <hr>
            <h2>Relevant Literature</h2>
<p>Notice something missing? Use the <strong>Add Source</strong> button to submit new references. You may also import a <code>.bib</code> file and the entries will be saved to our Supabase database. You will be prompted to log in before adding entries.</p>
            <div class="add-source-controls">
                <label for="bib-upload" class="button">Upload .bib</label>
                <input id="bib-upload" type="file" accept=".bib" hidden>
                <button id="add-source-btn" class="button" type="button">Add Source</button>
            </div>

            <div class="search-controls">
                <label for="lit-search">Search:</label>
                <input type="search" id="lit-search" placeholder="Search literature">
            </div>
            
            <div class="controls-row">
                <div class="filter-controls">
                    <label for="lit-axis-filter">Axis:</label>
                    <select id="lit-axis-filter" multiple size="1">
                        <option value="">All</option>
                    </select>
                    <label for="lit-construct-filter">Construct:</label>
                    <select id="lit-construct-filter" multiple size="1">
                        <option value="">All</option>
                    </select>
                    <label for="lit-field-filter">Field/Topic:</label>
                    <select id="lit-field-filter" multiple size="1">
                        <option value="">All</option>
                    </select>
                </div>
                <div class="sort-controls">
                    <label for="lit-sort">Sort by:</label>
                    <select id="lit-sort">
                        <option value="year">Year</option>
                        <option value="author">Author</option>
                        <option value="title">Title</option>
                    </select>
                </div>
            </div>
            <div class="table-scroll">
            <table id="lit-table">
                <thead>
                    <tr>
                        <th><input type="checkbox" id="lit-select-all"></th>
                        <th>Title</th>
                        <th>Author(s)</th>
                        <th>Year</th>
                        <th>Relevance</th>
                        <th>Construct</th>
                        <th>Axis</th>
                        <th>Significance <span class="info-icon" title="0 = not significant, 5 = highly significant">?</span></th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
            </div>
        </section>
        <div class="bibtex-controls">
            <!--<a class="button" href="#" id="bibtex-download">Download BibTeX</a> -->
            <a class="button" href="#" id="bibtex-export-all">Export all as BibTeX</a>
            <a class="button" href="#" id="bibtex-export-filtered" title="Export currently filtered list">Export filtered</a>
            <button id="edit-lit-btn" class="button">Edit</button>
            <button id="delete-lit-btn" class="button">Delete</button>
        </div>

            <hr style="margin-top: 40px; margin-bottom: 20px;">

            <div style="padding:20px; background-color:#f9f9f9; border-radius:8px; border: 1px solid #ddd;">
              <hr>
              <h2>Collaborative Literature Review</h2>
              <p>
                We encourage all contributors to help build our interdisciplinary literature review directly in our shared Overleaf project. Your input is essential in identifying and synthesizing relevant sources from philosophy, psychology, neuroscience, and computer science.
              </p>
              <p style="margin-top:15px;">
                ðŸ”— <a href="https://www.overleaf.com/4957755681mcqwpwkcyjrq#be11ce" target="_blank" style="font-weight:bold; color:#0066cc;">Access the collaborative Overleaf document here</a>
              </p>
              <p style="font-size: 0.9em; color: #666;">
                (No Overleaf account is required to view or edit. Please add brief summaries, relevant references, and foundational resources.)
              </p>
            </div>

    </main>
    <footer>
        <p>&copy; EQ AI Research Collaborative</p>
    </footer>
    <script>

    let literature = [];
    let filteredLiterature = [];

    function toTitle(text) {
        return text.replace(/(^|\s)\S/g, t => t.toUpperCase());
    }

    const selectedLit = new Set();
    let selectedLitId = null;

    function toBibtex(item) {
        const type = item.journal ? 'article' : 'book';
        const keyAuthor = (item.authors || 'ref').split(/[ ,]/)[0].replace(/[^a-zA-Z0-9]/g, '') || 'ref';
        const key = keyAuthor + (item.year || '');
        const mapping = {
            title: 'title',
            authors: 'author',
            journal: 'journal',
            publisher: 'publisher',
            volume: 'volume',
            number: 'number',
            pages: 'pages',
            year: 'year',
            url: 'url',
            doi: 'doi',
            construct: 'sera-construct',
            axis: 'sera-axis',
            keywords: 'keywords',
            relevance: 'note'
        };
        const fields = {};
        for (const [prop, tag] of Object.entries(mapping)) {
            let val = item[prop];
            if (val === undefined || val === null || val === '' || (Array.isArray(val) && !val.length)) continue;
            if (prop === 'keywords') val = Array.isArray(val) ? val.join(', ') : val;
            fields[tag] = val;
        }
        for (const [k,v] of Object.entries(item)) {
            if (!(k in mapping) && k !== '__index' && v !== undefined && v !== null && v !== '' && !(Array.isArray(v) && !v.length)) {
                fields[k] = Array.isArray(v) ? v.join(', ') : v;
            }
        }
        const body = Object.entries(fields).map(([k,v]) => `  ${k} = {${v}}`).join(',\n');
        return `@${type}{${key},\n${body}\n}`;
    }

    function downloadFile(content, filename) {
        const blob = new Blob([content], {type: 'text/x-bibtex'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        URL.revokeObjectURL(url);
        a.remove();
    }

    function updateSelectAll() {
        const cbs = document.querySelectorAll('#lit-table tbody .lit-check');
        const allChecked = cbs.length && Array.from(cbs).every(cb => cb.checked);
        document.getElementById('lit-select-all').checked = allChecked;
    }




    function renderLit(items) {
        const tbody = document.querySelector('#lit-table tbody');
        tbody.innerHTML = '';
        items.forEach(l => {
            const checked = selectedLit.has(l.__index) ? 'checked' : '';
            const row = document.createElement('tr');
            row.className = 'lit-row';
            row.dataset.lid = l.id ?? l.__index;
            row.id = `lit-row-${l.id ?? l.__index}`;
            row.innerHTML = `
                <td><input type="checkbox" class="lit-check" data-index="${l.__index}" ${checked}></td>
                <td>${l.title}</td>
                <td>${l.authors}</td>
                <td>${l.year}</td>
                <td>${l.relevance || ''}</td>
                <td>${(Array.isArray(l.construct) ? l.construct : (l.construct || '').split(/[,;]+/)).map(c => c.trim()).filter(Boolean).join('<br>')}</td>
                <td>${l.axis}</td>
                <td><div class="star-rating lit-rating" data-index="${l.__index}"></div></td>`;
            const extra = document.createElement('tr');
            const id = `ldetail-${l.__index}`;
            row.dataset.target = id;
            extra.className = 'lit-extra';
            extra.id = id;
            extra.style.display = 'none';
            const keywords = Array.isArray(l.keywords) ? l.keywords.join(', ') : (l.keywords || '');
            extra.innerHTML = `
                <td colspan="8">${l.publisher ? `<strong>Publisher:</strong> ${l.publisher}<br>` : ''}
                ${l.journal ? `<strong>Journal:</strong> ${l.journal}<br>` : ''}
                ${l.volume ? `<strong>Volume:</strong> ${l.volume} ` : ''}${l.number ? ` <strong>Number:</strong> ${l.number}` : ''}${(l.volume||l.number)?'<br>':''}
                ${l.pages ? `<strong>Pages:</strong> ${l.pages}<br>` : ''}
                ${l.url ? `<strong>URL:</strong> <a href="${l.url}">${l.url}</a><br>` : ''}
                ${l.category ? `<strong>Category:</strong> ${l.category}<br>` : ''}
                ${keywords ? `<strong>Keywords:</strong> ${keywords}` : ''}</td>`;
            tbody.appendChild(row);
            tbody.appendChild(extra);
        });
        tbody.querySelectorAll('.lit-check').forEach(cb => {
            cb.addEventListener('change', () => {
                const idx = parseInt(cb.dataset.index, 10);
                if (cb.checked) selectedLit.add(idx); else selectedLit.delete(idx);
                updateSelectAll();
            });
        });
        tbody.querySelectorAll('.lit-row').forEach(r => {
            r.addEventListener('click', e => {
                if (e.target.classList.contains('lit-check') || e.target.closest('.star-rating')) return;
                tbody.querySelectorAll('.lit-row').forEach(x => x.classList.remove('selected'));
                r.classList.add('selected');
                selectedLitId = r.dataset.lid || r.id.replace('lit-row-','');
                const target = document.getElementById(r.dataset.target);
                if (target) {
                    target.style.display = target.style.display === 'none' || !target.style.display ? 'table-row' : 'none';
                }
            });
        });
        updateSelectAll();
        initRatings('.lit-rating', 'lit-rating');
    }

    function applyLitFilters() {
        const q = document.getElementById('lit-search').value.trim().toLowerCase();
        const axisVals = Array.from(document.getElementById('lit-axis-filter').selectedOptions).map(o=>o.value).filter(Boolean);
        const constructVals = Array.from(document.getElementById('lit-construct-filter').selectedOptions).map(o=>o.value).filter(Boolean);
        const fieldVals = Array.from(document.getElementById('lit-field-filter').selectedOptions).map(o=>o.value).filter(Boolean);
        let items = literature.filter(l => {
            if (axisVals.length && !axisVals.some(a => (l.axis || '').toLowerCase().includes(a))) return false;
            const catList = Array.isArray(l.category) ? l.category : (l.category || '').split(',').map(c=>c.trim().toLowerCase()).filter(Boolean);
            if (fieldVals.length && !fieldVals.some(f => catList.includes(f))) return false;
            if (constructVals.length) {
                const list = Array.isArray(l.construct) ? l.construct : (l.construct || '').split(/[,;]+/);
                if (!constructVals.some(v => list.some(c => c.trim().toLowerCase() === v))) return false;
            }
            if (q) {
                const text = `${l.title || ''} ${l.authors || ''} ${l.relevance || ''}`.toLowerCase();
                if (!text.includes(q)) return false;
            }
            return true;
        });

        const sortVal = document.getElementById('lit-sort').value;
        if (sortVal === 'title') items.sort((a,b)=>a.title.localeCompare(b.title));
        else if (sortVal === 'author') items.sort((a,b)=>a.authors.localeCompare(b.authors));
        else items.sort((a,b)=>(a.year||0)-(b.year||0));
        filteredLiterature = items;
        renderLit(items);
    }

    async function loadLiterature() {
        if (!window.bibtexParse) {
            try {
                const mod = await import('https://cdn.jsdelivr.net/npm/bibtex-parse-js/+esm');
                window.bibtexParse = mod.default || mod;
            } catch (e) {
                console.error('Failed to load BibTeX parser', e);
            }
        }

        let lit = [];
        const useSupabase = window.SUPABASE_URL && window.SUPABASE_ANON_KEY && typeof fetchLiterature === 'function';
        if (useSupabase) {
            for (let i=0; i<20 && !window.supabase && !supabase; i++) await new Promise(r=>setTimeout(r,100));
            if (window.supabase || supabase) {
                try { lit = await fetchLiterature(); } catch(e) { console.error(e); lit = []; }
            }
        } else {
            try { lit = await (await fetch('data/literature.json')).json(); } catch(e) { lit = []; }
        }

        literature = lit.map((l, i) => Object.assign({__index: i, significance: l.significance || 0}, l));

        const axisSet = new Set();
        const fieldSet = new Set();
        const constructSet = new Set();
        literature.forEach(l => {
            if (l.axis) l.axis.split(',').forEach(a => axisSet.add(a.trim()));
            if (l.category) {
                const cats = Array.isArray(l.category) ? l.category : l.category.split(',');
                cats.forEach(c => fieldSet.add(c.trim().toLowerCase()));
            }
            const list = Array.isArray(l.construct) ? l.construct : (l.construct || '').split(/[,;]+/);
            list.forEach(c => constructSet.add(c.trim()));
        });

        const axisF = document.getElementById('lit-axis-filter');
        const axisOrder = ['sense','explain','respond','adapt','extended'];
        axisOrder.forEach(a => { if (axisSet.has(a)) axisF.appendChild(new Option(a.charAt(0).toUpperCase()+a.slice(1), a)); });
        const fieldF = document.getElementById('lit-field-filter');
        const fieldOrder = ['psychology','philosophy of mind','computer science','ethics','other'];
        fieldOrder.forEach(f => { if (fieldSet.has(f)) fieldF.appendChild(new Option(toTitle(f), f)); });
        const constructF = document.getElementById('lit-construct-filter');
        Array.from(constructSet)
            .sort((a,b)=>a.toLowerCase().localeCompare(b.toLowerCase()))
            .forEach(c => { if (c) constructF.appendChild(new Option(c, c.toLowerCase())); });

        enableMultiSelectDropdown(axisF);
        enableMultiSelectDropdown(fieldF);
        enableMultiSelectDropdown(constructF);

        document.getElementById('lit-sort').value = 'author';
        applyLitFilters();

        document.getElementById('lit-sort').addEventListener('change', applyLitFilters);
        axisF.addEventListener('change', applyLitFilters);
        fieldF.addEventListener('change', applyLitFilters);
        constructF.addEventListener('change', applyLitFilters);
        document.getElementById('lit-search').addEventListener('input', applyLitFilters);

        document.getElementById('lit-select-all').addEventListener('change', e => {
            document.querySelectorAll('#lit-table tbody .lit-check').forEach(cb => {
                cb.checked = e.target.checked;
                const idx = parseInt(cb.dataset.index, 10);
                if (e.target.checked) selectedLit.add(idx); else selectedLit.delete(idx);
            });
        });

        document.getElementById('bibtex-download').addEventListener('click', e => {
            e.preventDefault();
            const items = Array.from(selectedLit).map(i => literature.find(l => l.__index === i)).filter(Boolean);
            if (!items.length) return;
            const content = items.map(toBibtex).join('\n\n');
            downloadFile(content, 'references.bib');
        });

        document.getElementById('bibtex-export-all').addEventListener('click', e => {
            e.preventDefault();
            if (!literature.length) return;
            const content = literature.map(toBibtex).join('\n\n');
            downloadFile(content, 'references.bib');
        });

        document.getElementById('bibtex-export-filtered').addEventListener('click', e => {
            e.preventDefault();
            const items = filteredLiterature.length ? filteredLiterature : literature;
            if (!items.length) return;
            const content = items.map(toBibtex).join('\n\n');
            downloadFile(content, 'references.bib');
        });

        document.getElementById('bib-upload').addEventListener('change', e => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = async () => {
                const entries = parseBibtex(reader.result);
                const titles = new Set(literature.map(l => (l.title || '').toLowerCase()));
                const dois = new Set(literature.map(l => (l.url || '').replace(/https?:\/\/(dx\.)?doi.org\//i, '').toLowerCase()));
                let maxIndex = Math.max(0, ...literature.map(l => l.__index || 0));
                for (const en of entries) {
                    const t = (en.title || '').toLowerCase();
                    const d = (en.doi || en.url || '').replace(/https?:\/\/(dx\.)?doi.org\//i, '').toLowerCase();
                    if (titles.has(t) || (d && dois.has(d))) continue;
                    const obj = Object.assign({construct: '', axis: '', relevance: '', significance: 0}, en);
                    obj.__index = ++maxIndex;
                    if (authed && typeof addLiterature === 'function') {
                        try {
                            const { data, error } = await addLiterature(obj);
                            if (!error && data && data[0]) Object.assign(obj, data[0]);
                        } catch (err) { console.error(err); }
                    }
                    literature.push(obj);
                    titles.add(t);
                    if (d) dois.add(d);
                }
                applyLitFilters();
                e.target.value = '';
            };
            reader.readAsText(file);
        });
    }

document.addEventListener('DOMContentLoaded', loadLiterature);
let authed = false;

async function startAddLit() {
    if (!authed) { if (!(await authenticate())) return; authed = true; }
    document.getElementById('lit-add-row')?.remove();
    const tbody = document.querySelector('#lit-table tbody');
    const addRow = document.createElement('tr');
    addRow.id = 'lit-add-row';
    addRow.innerHTML = `<td colspan="8"><form id="lit-add-form">
        <label>Title: <input type="text" name="title" required></label>
        <label>Authors: <input type="text" name="authors"></label>
        <label>Year: <input type="number" name="year"></label>
        <label>Publisher: <input type="text" name="publisher"></label>
        <label>Journal: <input type="text" name="journal"></label>
        <label>Volume: <input type="text" name="volume"></label>
        <label>Number: <input type="text" name="number"></label>
        <label>Pages: <input type="text" name="pages"></label>
        <label>URL: <input type="text" name="url"></label>
        <label>Category: <select name="category" multiple size="1">
            <option value="psychology">Psychology</option>
            <option value="philosophy of mind">Philosophy of Mind</option>
            <option value="computer science">Computer Science</option>
            <option value="ethics">Ethics</option>
            <option value="other">Other</option>
        </select></label>
        <label>Keywords: <input type="text" name="keywords" placeholder="comma separated"></label>
        <label>Construct: <input type="text" name="construct"></label>
        <label>Axis: <select name="axis" multiple size="1">
            <option value="sense">Sense</option>
            <option value="explain">Explain</option>
            <option value="respond">Respond</option>
            <option value="adapt">Adapt</option>
            <option value="extended">Extended</option>
        </select></label>
        <label>Relevance: <textarea name="relevance" rows="3"></textarea></label>
        <button type="submit">Add</button>
        <button type="button" id="lit-add-cancel">Cancel</button>
        <div class="form-error" style="display:none"></div>
    </form></td>`;
    tbody.prepend(addRow);
    const form = document.getElementById('lit-add-form');
    const errorDiv = form.querySelector('.form-error');
    enableMultiSelectDropdown(form.elements.axis);
    enableMultiSelectDropdown(form.elements.category);
    form.addEventListener('submit', async e => {
        e.preventDefault();
        errorDiv.textContent = '';
        errorDiv.style.display = 'none';
        if (!authed) { if (!(await authenticate())) return; authed = true; }
        const axisArr = Array.from(form.elements.axis.selectedOptions).map(o => o.value);
        const catArr = Array.from(form.elements.category.selectedOptions).map(o => o.value);
        const obj = {
            title: e.target.title.value,
            authors: e.target.authors.value,
            year: parseInt(e.target.year.value,10) || null,
            publisher: e.target.publisher.value,
            journal: e.target.journal.value,
            volume: e.target.volume.value,
            number: e.target.number.value,
            pages: e.target.pages.value,
            url: e.target.url.value,
            category: catArr.join(', '),
            keywords: e.target.keywords.value.split(',').map(s=>s.trim()).filter(Boolean),
            construct: e.target.construct.value,
            axis: axisArr,
            relevance: e.target.relevance.value,
            significance: 0
        };
        if (typeof addLiterature === 'function') {
            try {
                const { data, error } = await addLiterature(obj);
                if (error) {
                    errorDiv.textContent = error.message || error;
                    errorDiv.style.display = 'block';
                    return;
                }
                if (data && data[0]) Object.assign(obj, data[0]);
            } catch (err) {
                console.error(err);
                errorDiv.textContent = err.message || err;
                errorDiv.style.display = 'block';
                return;
            }
        }
        obj.axis = axisArr.join(', ');
        obj.__index = Math.max(0, ...literature.map(l => l.__index || 0)) + 1;
        literature.push(obj);
        addRow.remove();
        applyLitFilters();
    });
    document.getElementById('lit-add-cancel').addEventListener('click', () => addRow.remove());
}

async function startEditLit() {
    if (!authed) { if (!(await authenticate())) return; authed = true; }
    if (selectedLitId === null) { alert('Select an entry first.'); return; }
    const item = literature.find(l => (l.id ?? l.__index) == selectedLitId);
    if (!item) return;
    const axisVals = Array.isArray(item.axis) ? item.axis : (item.axis || '').split(',').map(a=>a.trim());
    const formHtml = `<form id="lit-edit-form">
        <label>Title: <input type="text" name="title" value="${item.title}" placeholder="Paper title"></label>
        <label>Authors: <input type="text" name="authors" value="${item.authors || ''}" placeholder="Author list"></label>
        <label>Year: <input type="number" name="year" value="${item.year || ''}" placeholder="2024"></label>
        <label>Publisher: <input type="text" name="publisher" value="${item.publisher || ''}" placeholder="Publisher"></label>
        <label>Journal: <input type="text" name="journal" value="${item.journal || ''}" placeholder="Journal name"></label>
        <label>Volume: <input type="text" name="volume" value="${item.volume || ''}" placeholder="Volume"></label>
        <label>Number: <input type="text" name="number" value="${item.number || ''}" placeholder="Number"></label>
        <label>Pages: <input type="text" name="pages" value="${item.pages || ''}" placeholder="Pages"></label>
        <label>URL: <input type="url" name="url" value="${item.url || ''}" placeholder="https://..."></label>
        <label>Category: <select name="category" multiple size="1">
            <option value="psychology" ${item.category && item.category.toLowerCase().includes('psychology') ? 'selected' : ''}>Psychology</option>
            <option value="philosophy of mind" ${item.category && item.category.toLowerCase().includes('philosophy of mind') ? 'selected' : ''}>Philosophy of Mind</option>
            <option value="computer science" ${item.category && item.category.toLowerCase().includes('computer science') ? 'selected' : ''}>Computer Science</option>
            <option value="ethics" ${item.category && item.category.toLowerCase().includes('ethics') ? 'selected' : ''}>Ethics</option>
            <option value="other" ${item.category && item.category.toLowerCase().includes('other') ? 'selected' : ''}>Other</option>
        </select></label>
        <label>Keywords: <input type="text" name="keywords" value="${Array.isArray(item.keywords) ? item.keywords.join(', ') : (item.keywords || '')}" placeholder="comma separated"></label>
        <label>Axis: <select name="axis" multiple size="1">
            <option value="sense" ${axisVals.includes('sense') ? 'selected' : ''}>Sense</option>
            <option value="explain" ${axisVals.includes('explain') ? 'selected' : ''}>Explain</option>
            <option value="respond" ${axisVals.includes('respond') ? 'selected' : ''}>Respond</option>
            <option value="adapt" ${axisVals.includes('adapt') ? 'selected' : ''}>Adapt</option>
            <option value="extended" ${axisVals.includes('extended') ? 'selected' : ''}>Extended</option>
        </select></label>
        <div class="edit-buttons">
            <button type="submit" class="button">Save</button>
            <button type="button" id="lit-edit-cancel" class="button">Cancel</button>
        </div>
    </form>`;
    const form = showEditOverlay(formHtml);
    enableMultiSelectDropdown(form.elements.axis);
    enableMultiSelectDropdown(form.elements.category);
    form.addEventListener('submit', async e => {
        e.preventDefault();
        if (!authed) { if (!(await authenticate())) return; authed = true; }
        if (!confirm('Save changes?')) return;
        item.title = form.title.value;
        item.authors = form.authors.value;
        item.year = parseInt(form.year.value,10) || null;
        item.publisher = form.publisher.value;
        item.journal = form.journal.value;
        item.volume = form.volume.value;
        item.number = form.number.value;
        item.pages = form.pages.value;
        item.url = form.url.value;
        const catArrEdit = Array.from(form.elements.category.selectedOptions).map(o => o.value);
        item.category = catArrEdit.join(', ');
        item.keywords = form.keywords.value.split(',').map(s=>s.trim()).filter(Boolean);
        const axisArr = Array.from(form.elements.axis.selectedOptions).map(o => o.value);
        item.axis = axisArr.join(', ');
        if (item.id && typeof updateLiterature === 'function') await updateLiterature(item.id, {
            title: item.title,
            authors: item.authors,
            year: item.year,
            publisher: item.publisher,
            journal: item.journal,
            volume: item.volume,
            number: item.number,
            pages: item.pages,
            url: item.url,
            category: item.category,
            keywords: item.keywords,
            axis: axisArr
        });
        hideEditOverlay();
        applyLitFilters();
    });
    document.getElementById('lit-edit-cancel').addEventListener('click', hideEditOverlay);
}

async function deleteSelectedLit() {
    if (selectedLitId === null) { alert('Select an entry first.'); return; }
    const idx = literature.findIndex(l => (l.id ?? l.__index) == selectedLitId);
    if (idx === -1) return;
    if (!authed) { if (!(await authenticate())) return; authed = true; }
    if (!confirm('Delete this entry?')) return;
    const item = literature[idx];
    if (item.id && typeof deleteLiterature === 'function') await deleteLiterature(item.id);
    literature.splice(idx,1);
    selectedLitId = null;
    applyLitFilters();
}



document.getElementById('edit-lit-btn').addEventListener('click', startEditLit);
document.getElementById('delete-lit-btn').addEventListener('click', deleteSelectedLit);
document.getElementById('add-source-btn').addEventListener('click', startAddLit);

// Confirm before saving new or updated literature
document.getElementById('literature-form')?.addEventListener('submit', e => {
    if (!confirm('Save changes?')) {
        e.preventDefault();
    }
});
    </script>
    <script src="env.js"></script>
    <script src="script.js"></script>
</body>
</html>
